<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">

  <meta name="author" content="Anton Dubovik">
  <meta name="keywords" content="dubovik, haskell, programming, anton dubovik">
  <meta name="description" content="Home page of Anton Dubovik">
  <meta name="generator" content="hakyll">

  <link rel="stylesheet" href="../static/main.css" />
  <link rel="stylesheet" href="../static/syntax.css" />

  <!-- Google webfonts -->
  <link href="http://fonts.googleapis.com/css?family=Droid+Sans+Mono|Ubuntu&subset=latin,cyrillic" rel="stylesheet" type="text/css">

  <!--[if IE]>
  <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.4/jquery.min.js"></script>

  <title>Tying the knot BFS</title>
</head>

<body>

  <script type="text/javascript">
    var disqus_developer = 1;
</script>

<article>

<h1 class="post_title">Tying the knot BFS</h1>
<div class="post_date">posted on Jan 1 2015</div>

<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="co">{-# language</span>
<span class="co">&gt;    RankNTypes</span>
<span class="co">&gt;  #-}</span></code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Control.Arrow</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Debug.Trace</span></code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">Path</span> a <span class="fu">=</span> [a]</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Tree</span> a [<span class="dt">Tree</span> a]
<span class="ot">&gt;</span>   <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; size ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> size (<span class="dt">Tree</span> _ ts) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> sum (map size ts)</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; get ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> a
<span class="ot">&gt;</span> get (<span class="dt">Tree</span> a _) <span class="fu">=</span> a</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; ch ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [<span class="dt">Tree</span> a]
<span class="ot">&gt;</span> ch (<span class="dt">Tree</span> _ ts) <span class="fu">=</span> ts</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; tracesFirst ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a
<span class="ot">&gt;</span> tracesFirst x <span class="fu">=</span> (x<span class="fu">==</span>x) <span class="ot">`seq`</span> x</code></pre>
<p>Традиционно алгоритм обхода графа в ширину определяется с помощь очереди. Сначала в очередь добавляется корневая вершина. Потом из очереди извлекается вершина, в конец очереди добавляются смежные ей вершины и так пока очередь не пуста. Извлекаемые из очереди вершины будут как раз идти в порядке обхода в ширину.</p>
<p>Этот алгоритм можно прямолинейно реализовать в Haskell. Для простоты я ограничился деревьями (для графов нужно поддерживать список посещенных вершин).</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; levelOrderQueue ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [<span class="dt">Tree</span> a]
<span class="ot">&gt;</span> levelOrderQueue t <span class="fu">=</span> go (enqueue t emptyQueue)
<span class="ot">&gt;</span>   <span class="kw">where</span></code></pre>
<p>Функции для работы с очередью.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>     isEmpty            <span class="fu">=</span> null
<span class="ot">&gt;</span>     emptyQueue         <span class="fu">=</span> []
<span class="ot">&gt;</span>     dequeue            <span class="fu">=</span> head <span class="fu">&amp;&amp;&amp;</span> tail
<span class="ot">&gt;</span>     enqueue x          <span class="fu">=</span> (<span class="fu">++</span> [x])
<span class="ot">&gt;</span>     enqueueMany []     <span class="fu">=</span> id
<span class="ot">&gt;</span>     enqueueMany (x<span class="fu">:</span>xs) <span class="fu">=</span> enqueueMany xs <span class="fu">.</span> enqueue x</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>     go q
<span class="ot">&gt;</span>       <span class="fu">|</span> isEmpty q <span class="fu">=</span> []
<span class="ot">&gt;</span>       <span class="fu">|</span> otherwise
<span class="ot">&gt;</span>       <span class="fu">=</span> <span class="kw">let</span> (t,q') <span class="fu">=</span> dequeue q
<span class="ot">&gt;</span>         <span class="kw">in</span>  t <span class="fu">:</span> go (enqueueMany (ch t) q')</code></pre>
<p>‘levelOrderQueue’ выдает список поддеревьев в порядке обхода в ширину т.е. поуровнево.</p>
<p>Собственно поиск в ширину параметризуется функцией, которая перечисляет поддеревья в подрядке обхода в ширину (например ‘levelOrderQueue’), и предикатом поиска ‘pred’:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; bfs ::</span> (forall a<span class="fu">.</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [<span class="dt">Tree</span> a])
<span class="ot">&gt;</span>     <span class="ot">-&gt;</span> (<span class="dt">Tree</span> (<span class="dt">Path</span> a) <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
<span class="ot">&gt;</span>     <span class="ot">-&gt;</span> <span class="dt">Tree</span> a
<span class="ot">&gt;</span>     <span class="ot">-&gt;</span> [<span class="dt">Path</span> a]
<span class="ot">&gt;</span> bfs levelOrder pred <span class="fu">=</span> map get
<span class="ot">&gt;</span>                     <span class="fu">.</span> filter pred
<span class="ot">&gt;</span>                     <span class="fu">.</span> levelOrder
<span class="ot">&gt;</span>                     <span class="fu">.</span> pathsTree
<span class="ot">&gt;</span>   <span class="kw">where</span>
<span class="ot">&gt;     pathsTree ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> [a]
<span class="ot">&gt;</span>     pathsTree <span class="fu">=</span> descend []
<span class="ot">&gt;</span>       <span class="kw">where</span>
<span class="ot">&gt;</span>         descend path (<span class="dt">Tree</span> a ts) <span class="fu">=</span>
<span class="ot">&gt;</span>           <span class="kw">let</span> path' <span class="fu">=</span> a<span class="fu">:</span>path
<span class="ot">&gt;</span>           <span class="kw">in</span>  <span class="dt">Tree</span> path' (map (descend path') ts)</code></pre>
<p>Как таковой ‘bfs’ нам не сильно интересен в отличие от различных вариантов реализации ‘levelOrder’.</p>
<p>‘levelOrderQueue’ использует наиболее простую реализацию очереди через список, которая имеет O(n) сложность для операции вставки в конец - ‘enqueue’.</p>
<p>Можно было бы реализовать очередь через два стека - операции вставки и извлечения из очереди занимали бы амортизированное O(1). Что хорошо, но хотелось бы настоящей константы.</p>
<p>Добавим в алгоритм отладочную печать очереди:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; levelOrderQueueTrace ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [<span class="dt">Tree</span> a]
<span class="ot">&gt;</span> levelOrderQueueTrace t <span class="fu">=</span> go (enqueue t emptyQueue)
<span class="ot">&gt;</span>   <span class="kw">where</span>
<span class="ot">&gt;</span>     traceQ s q <span class="fu">=</span> trace (s <span class="fu">++</span> <span class="st">&quot; &quot;</span> <span class="fu">++</span> (show <span class="fu">.</span> map get <span class="fu">$</span> q)) q
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>     isEmpty            <span class="fu">=</span> null
<span class="ot">&gt;</span>     emptyQueue         <span class="fu">=</span> []
<span class="ot">&gt;</span>     enqueue x          <span class="fu">=</span> traceQ <span class="st">&quot;enqueue&quot;</span> <span class="fu">.</span> (<span class="fu">++</span> [x])
<span class="ot">&gt;</span>     dequeue            <span class="fu">=</span> head <span class="fu">&amp;&amp;&amp;</span> (traceQ <span class="st">&quot;dequeue&quot;</span> <span class="fu">.</span> tail)
<span class="ot">&gt;</span>     enqueueMany []     <span class="fu">=</span> id
<span class="ot">&gt;</span>     enqueueMany (x<span class="fu">:</span>xs) <span class="fu">=</span> enqueueMany xs <span class="fu">.</span> enqueue x</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>     go q
<span class="ot">&gt;</span>       <span class="fu">|</span> isEmpty q <span class="fu">=</span> []
<span class="ot">&gt;</span>       <span class="fu">|</span> otherwise
<span class="ot">&gt;</span>       <span class="fu">=</span> <span class="kw">let</span> (t,q') <span class="fu">=</span> dequeue q
<span class="ot">&gt;</span>         <span class="kw">in</span>  t <span class="fu">:</span> go (enqueueMany (ch t) q')</code></pre>
<p>и рассмотрим, какие значения принимает очередь в ходе выполнения алгоритма на полном бинарном дереве высоты 3:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> print <span class="fu">$</span> tracesFirst <span class="fu">$</span> map get <span class="fu">$</span> levelOrderQueueTrace <span class="fu">$</span> binTree <span class="dv">3</span>
enqueue [<span class="dv">1</span>]
dequeue []
enqueue [<span class="dv">2</span>]
enqueue [<span class="dv">2</span>,<span class="dv">3</span>]
dequeue [<span class="dv">3</span>]
enqueue [<span class="dv">3</span>,<span class="dv">4</span>]
enqueue [<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>]
dequeue [<span class="dv">4</span>,<span class="dv">5</span>]
enqueue [<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]
enqueue [<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>]
dequeue [<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>]
dequeue [<span class="dv">6</span>,<span class="dv">7</span>]
dequeue [<span class="dv">7</span>]
dequeue []
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>]</code></pre>
<p>После выравнивания становится очевидно, что очередь принимает значения некоторого подотрезка списка деревьев в breadth-first порядке. Начало и конец отрезка смещаются вправо при каждом вызове ‘dequeue’ и ‘enqueue’ соответственно.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">enqueue [<span class="dv">1</span>]
dequeue  []
enqueue   [<span class="dv">2</span>]
enqueue   [<span class="dv">2</span>,<span class="dv">3</span>]
dequeue     [<span class="dv">3</span>]
enqueue     [<span class="dv">3</span>,<span class="dv">4</span>]
enqueue     [<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>]
dequeue       [<span class="dv">4</span>,<span class="dv">5</span>]
enqueue       [<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]
enqueue       [<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>]
dequeue         [<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>]
dequeue           [<span class="dv">6</span>,<span class="dv">7</span>]
dequeue             [<span class="dv">7</span>]
dequeue              []
        [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>]</code></pre>
<p>Так почему бы не совместить результирующий список деревьев и очередь в один список?</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; levelOrderCorecQueue ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [<span class="dt">Tree</span> a]
<span class="ot">&gt;</span> levelOrderCorecQueue t <span class="fu">=</span> queue
<span class="ot">&gt;</span>   <span class="kw">where</span>
<span class="ot">&gt;</span>     queue <span class="fu">=</span> t <span class="fu">:</span> go queue
<span class="ot">&gt;</span>     go [] <span class="fu">=</span> []
<span class="ot">&gt;</span>     go (<span class="dt">Tree</span> _ ts <span class="fu">:</span> rest) <span class="fu">=</span> ts <span class="fu">++</span> go rest</code></pre>
<p>Указатели на начало и конец очереди здесь поддерживаются неявно в функции ‘go’. В ней аргумент обозначает начало очереди, а результат - конец. Сопоставление с образцом (:) - аналог ‘dequeue’, (t:) - ‘enqueue’, (ts++) - ‘enqueueMany ts’.</p>
<p>Что интересно, значение аргумента функции ‘go’ зависит от результата этой функции за счет value recursion ‘queue’.</p>
<p>‘levelOrderCorecQueue’ корректно выдаст первые ‘n’ поддеревьев, где ‘n’ - количество вершин в дереве, но после этого ghc просто зависнет. Сопоставление по образцу [] в ‘go’ спровоцирует очередной вызов ‘go’ и так до бесконечности.</p>
<p>Можно брать ровно столько поддеревьев, сколько их в дереве:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; levelOrderCorecQueue' ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [<span class="dt">Tree</span> a]
<span class="ot">&gt;</span> levelOrderCorecQueue' t <span class="fu">=</span> take (size t)
<span class="ot">&gt;</span>                         <span class="fu">$</span> levelOrderCorecQueue t</code></pre>
<p>Однако, это не будет работать на бесконечных деревьях. Вычисление их размера займет бесконечно много времени.</p>
<p>Что ж поддержим размер очереди явно:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; levelOrderCorecQueueCount ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [<span class="dt">Tree</span> a]
<span class="ot">&gt;</span> levelOrderCorecQueueCount t <span class="fu">=</span> queue
<span class="ot">&gt;</span>   <span class="kw">where</span></code></pre>
<p>Вначале очередь содержит всего один элемент - корневое дерево.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>     queue <span class="fu">=</span> t <span class="fu">:</span> go <span class="dv">1</span> queue</code></pre>
<p>Если очередь пуста, алгоритм завершается.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>     go <span class="dv">0</span> _ <span class="fu">=</span> []</code></pre>
<p>Иначе из очереди извлекается один элемент (-1) и добавляется (length ts) новых к (n) уже имеющимся.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>     go n (<span class="dt">Tree</span> a ts <span class="fu">:</span> rest) <span class="fu">=</span> ts <span class="fu">++</span> go (n <span class="fu">-</span> <span class="dv">1</span> <span class="fu">+</span> length ts) rest</code></pre>
<p>Такая очередь называется корекурсивной очередью. Она описана в отличном туториале http://www.melding-monads.com/files/CorecQueues.pdf, где также предложен способ оформить такую очередь в typeclass ‘MonadQueue’ с функциями ‘enqueue’ и ‘dequeue’.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; sampleTree ::</span> <span class="dt">Tree</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> sampleTree <span class="fu">=</span>
<span class="ot">&gt;</span>   <span class="dt">Tree</span> <span class="dv">1</span>
<span class="ot">&gt;</span>     [ <span class="dt">Tree</span> <span class="dv">2</span>
<span class="ot">&gt;</span>       [ <span class="dt">Tree</span> <span class="dv">5</span> [] ]
<span class="ot">&gt;</span>     , <span class="dt">Tree</span> <span class="dv">3</span> []
<span class="ot">&gt;</span>     , <span class="dt">Tree</span> <span class="dv">4</span>
<span class="ot">&gt;</span>       [ <span class="dt">Tree</span> <span class="dv">6</span> [] ]
<span class="ot">&gt;</span>     ]</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; binTree ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> binTree d <span class="fu">=</span> go d <span class="dv">1</span>
<span class="ot">&gt;</span>   <span class="kw">where</span>
<span class="ot">&gt;     go ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span> <span class="dt">Int</span>
<span class="ot">&gt;</span>     go <span class="dv">1</span> n <span class="fu">=</span> <span class="dt">Tree</span> n []
<span class="ot">&gt;</span>     go d n <span class="fu">=</span> <span class="dt">Tree</span> n [ go (d<span class="fu">-</span><span class="dv">1</span>) (<span class="dv">2</span><span class="fu">*</span>n)
<span class="ot">&gt;</span>                     , go (d<span class="fu">-</span><span class="dv">1</span>) (<span class="dv">2</span><span class="fu">*</span>n<span class="fu">+</span><span class="dv">1</span>)
<span class="ot">&gt;</span>                     ]</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; infBinTree ::</span> <span class="dt">Tree</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> infBinTree <span class="fu">=</span> binTree <span class="dv">0</span></code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; main ::</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> main <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>   <span class="kw">let</span> printResult <span class="fu">=</span> print <span class="fu">.</span> tracesFirst <span class="fu">.</span> map get
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>       finTest msg alg <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>         putStrLn <span class="fu">$</span> <span class="st">&quot;Finite binary tree: &quot;</span> <span class="fu">++</span> msg
<span class="ot">&gt;</span>         printResult <span class="fu">$</span> alg sampleTree
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>       infTest msg alg <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>         putStrLn <span class="fu">$</span> <span class="st">&quot;Infinite binary tree: &quot;</span> <span class="fu">++</span> msg
<span class="ot">&gt;</span>         printResult <span class="fu">$</span> take <span class="dv">15</span> <span class="fu">$</span> alg infBinTree
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>   finTest <span class="st">&quot;levelOrderQueue&quot;</span> levelOrderQueue
<span class="ot">&gt;</span>   infTest <span class="st">&quot;levelOrderQueue&quot;</span> levelOrderQueue</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>   finTest <span class="st">&quot;levelOrderQueueTrace&quot;</span> levelOrderQueueTrace
<span class="ot">&gt;</span>   infTest <span class="st">&quot;levelOrderQueueTrace&quot;</span> levelOrderQueueTrace</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>   <span class="co">-- finTest &quot;levelOrderCorecQueue&quot; levelOrderCorecQueue  -- hangs</span>
<span class="ot">&gt;</span>   infTest <span class="st">&quot;levelOrderCorecQueue&quot;</span> levelOrderCorecQueue</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>   finTest <span class="st">&quot;levelOrderCorecQueue'&quot;</span> levelOrderCorecQueue'
<span class="ot">&gt;</span>   <span class="co">-- infTest &quot;levelOrderCorecQueue'&quot; levelOrderCorecQueue'  -- hangs</span></code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>   finTest <span class="st">&quot;levelOrderCorecQueueCount&quot;</span> levelOrderCorecQueueCount
<span class="ot">&gt;</span>   infTest <span class="st">&quot;levelOrderCorecQueueCount&quot;</span> levelOrderCorecQueueCount</code></pre>

 <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'dubovikinfo'; // required: replace example with your forum shortname
        var disqus_identifier = '/posts/2015-01-01-tying-the-knot-bfs.html';
        var disqus_url = 'http://dubovik.info' + '/posts/2015-01-01-tying-the-knot-bfs.html';
        var disqus_title = 'Tying the knot BFS';

        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>
      Please enable JavaScript to view the 
      <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
    </noscript>

</article>


  <footer>
    Generated by <a href="http://jaspervdj.be/hakyll/" target="_blank">hakyll</a>
    The entire source code of this website is <a href="http://github.com/adubovik/adubovik.github.io" target="_blank"> available at github</a>
    <br />
    © 2015 Anton Dubovik
  </footer>
</body>

</html>
